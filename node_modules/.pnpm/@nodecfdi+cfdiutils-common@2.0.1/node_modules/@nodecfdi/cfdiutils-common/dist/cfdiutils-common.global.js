var cfdiutilsCommon = (function (exports) {
  'use strict';

  // src/exceptions/dom-not-found-error.ts
  var DomNotFoundError = class extends Error {
    constructor(type) {
      super(`No ${type} was provided.`);
      this.name = `${type}NotFoundError`;
    }
  };

  // src/dom.ts
  var _dom;
  var _parser;
  var _serializer;
  var getParser = () => {
    if (!_parser) {
      throw new DomNotFoundError("DOMParser");
    }
    return _parser;
  };
  var getSerializer = () => {
    if (!_serializer) {
      throw new DomNotFoundError("XMLSerializer");
    }
    return _serializer;
  };
  var getDom = () => {
    if (!_dom) {
      throw new DomNotFoundError("DOMImplementation");
    }
    return _dom;
  };
  var install = (parser, serializer, dom) => {
    _parser = parser;
    _serializer = serializer;
    _dom = dom;
  };

  // src/utils/dom-validators.ts
  var DomValidators = {
    isElement(nodo) {
      return Boolean(nodo && nodo.nodeType === nodo.ELEMENT_NODE);
    },
    isAttr(nodo) {
      return Boolean(nodo && nodo.nodeType === nodo.ATTRIBUTE_NODE);
    },
    isText(nodo) {
      return Boolean(nodo && nodo.nodeType === nodo.TEXT_NODE);
    },
    isDocument(nodo) {
      return Boolean(nodo && nodo.nodeType === nodo.DOCUMENT_NODE);
    }
  };

  // src/utils/xml.ts
  var Xml = {
    documentElement(document) {
      if (!DomValidators.isElement(document.documentElement)) {
        throw new SyntaxError("Document does not have root element");
      }
      return document.documentElement;
    },
    ownerDocument(node) {
      if (!node.ownerDocument) {
        if (DomValidators.isDocument(node)) {
          return node;
        }
        throw new TypeError("node.ownerDocument is undefined but node is not a Document");
      }
      return node.ownerDocument;
    },
    newDocument(document) {
      if (!document) {
        document = getDom().createDocument(null, null, null);
      }
      return document;
    },
    newDocumentContent(content) {
      if (content === "") {
        throw new SyntaxError("Received xml string argument is empty");
      }
      const parser = getParser();
      try {
        const documentParse = parser.parseFromString(content, "text/xml");
        if (documentParse.getElementsByTagName("parsererror").length > 0) {
          throw new Error("Error parsing XML");
        }
        return Xml.newDocument(documentParse);
      } catch (error) {
        throw new SyntaxError(`Cannot create a Document from xml string, errors: ${JSON.stringify(error)}`);
      }
    },
    isValidXmlName(name) {
      if (name === "") {
        return false;
      }
      return /^[\p{L}_:][\p{L}\d_:.-]*$/u.test(name);
    },
    createElement(document, name, content = "") {
      return Xml.createDomElement(
        () => {
          if (!name) {
            throw new SyntaxError("Empty Name");
          }
          return document.createElement(name);
        },
        `Cannot create element with name ${name}`,
        content
      );
    },
    createDomElement(makeElement, errorMessage, content) {
      let element;
      let previousException;
      try {
        element = makeElement();
      } catch (error) {
        previousException = error;
      }
      if (!element || !DomValidators.isElement(element)) {
        throw new SyntaxError(`${errorMessage} on ${previousException ? previousException.message : "not is element"}`);
      }
      if (content !== "") {
        element.appendChild(Xml.ownerDocument(element).createTextNode(content));
      }
      return element;
    }
  };

  // src/nodes/attributes.ts
  var Attributes = class _Attributes extends Map {
    /**
     * Cast any value to string
     */
    static castValueToString(key, value) {
      if (value === null || value === void 0) {
        return void 0;
      }
      if (/boolean|number|string/.test(typeof value)) {
        return `${value}`;
      }
      if (typeof value === "object" && !Array.isArray(value)) {
        return value.toString();
      }
      throw new SyntaxError(`Cannot convert value of attribute ${key} to string`);
    }
    constructor(attributes = {}) {
      super();
      this.importRecord(attributes);
    }
    get(name) {
      const value = super.get(name);
      if (value === void 0) {
        return "";
      }
      return value;
    }
    set(name, value) {
      if (value === void 0 || value === null) {
        this.delete(name);
        return this;
      }
      if (!Xml.isValidXmlName(name)) {
        throw new SyntaxError(`Cannot set attribute with an invalid xml name: ${name}`);
      }
      super.set(name, value.toString());
      return this;
    }
    exists(name) {
      let found = false;
      for (const key of this.keys()) {
        if (name === key) {
          found = true;
          break;
        }
      }
      return found;
    }
    importRecord(attributes) {
      if (Object.keys(attributes).length > 0) {
        for (const [key, value] of Object.entries(attributes)) {
          const fixedValue = _Attributes.castValueToString(key, value);
          this.set(key, fixedValue);
        }
      }
      return this;
    }
    exportRecord() {
      const jsonResponse = {};
      for (const [key, value] of this.entries()) {
        jsonResponse[key] = value;
      }
      return jsonResponse;
    }
    /**
     * Array access implementation as attribute helpers
     */
    offsetExists(offset) {
      return this.exists(offset);
    }
    offsetGet(offset) {
      return this.get(offset);
    }
    offsetSet(offset, value) {
      this.set(offset, _Attributes.castValueToString(offset, value));
    }
    offsetUnset(offset) {
      super.delete(offset);
    }
  };

  // src/nodes/nodes-sorter.ts
  var NodesSorter = class _NodesSorter {
    /**
     * Internal compare Maps
     * @param a - map
     * @param b - map
     */
    static compareMaps(a, b) {
      let testValue;
      if (a.size !== b.size) {
        return false;
      }
      for (const [key, value] of a) {
        testValue = b.get(key);
        if (testValue !== value || testValue === void 0 && !b.has(key)) {
          return false;
        }
      }
      return true;
    }
    _order = /* @__PURE__ */ new Map();
    size;
    constructor(order = []) {
      this.setOrder(order);
    }
    /**
     * It takes only the unique strings names and sort using the order of appearance
     * @param names - unique strings
     */
    setOrder(names) {
      const order = new Map(Array.from(this.parseNames(names), (entry) => [entry[1], entry[0]]));
      if (_NodesSorter.compareMaps(this._order, order)) {
        return false;
      }
      this._order = order;
      this.size = order.size;
      return true;
    }
    parseNames(names) {
      const isValidName = (name) => Boolean(name) && typeof name === "string" && name !== "0";
      return new Map(
        [...new Set(names.filter((element) => isValidName(element)))].map((entry, index) => [index, entry])
      );
    }
    /**
     * The current order list
     */
    getOrder() {
      const flippedArray = new Map(Array.from(this._order, (entry) => [entry[1], entry[0]]));
      return [...flippedArray.values()];
    }
    sort(nodes) {
      if (this.size > 0) {
        nodes = this.stableArraySort(nodes, "compareNodesByName");
      }
      return nodes;
    }
    compareNodesByName(a, b) {
      const aNumber = this.valueByName(a.name());
      const bNumber = this.valueByName(b.name());
      return Math.sign(aNumber - bNumber);
    }
    valueByName(name) {
      const getOrder = this._order.get(name);
      return getOrder ?? this.size;
    }
    /**
     * This function is a replacement for sort that try to sort
     * but if items are equal then uses the relative position as second argument
     * @param input - NodeInterface
     * @param callable - function callable
     */
    stableArraySort(input, callable) {
      let list = input.map((entry, index) => ({
        item: entry,
        index
      }));
      const comparar = (a, b) => {
        let value = this[callable](a.item, b.item);
        if (value === 0) {
          value = Math.sign(a.index - b.index);
        }
        return value;
      };
      list = list.sort(comparar);
      return list.map((node) => node.item);
    }
  };

  // src/nodes/nodes.ts
  var Nodes = class _Nodes extends Array {
    _sorter;
    constructor(nodes = []) {
      super();
      this._sorter = new NodesSorter();
      this.importFromArray(nodes);
    }
    static get [Symbol.species]() {
      return Array;
    }
    add(...nodes) {
      let somethingChange = false;
      for (const node of nodes) {
        if (!this.exists(node)) {
          this.push(node);
          somethingChange = true;
        }
      }
      if (somethingChange) {
        this.order();
      }
      return this;
    }
    order() {
      this.splice(0, this.length, ...this._sorter.sort(this));
    }
    /**
     * It takes only the unique string names and sort using the order of appearance
     * @param names - names for order
     */
    setOrder(names) {
      if (this._sorter.setOrder(names)) {
        this.order();
      }
    }
    getOrder() {
      return this._sorter.getOrder();
    }
    remove(node) {
      const index = this.indexOf(node);
      if (index >= 0) {
        this.splice(index, 1);
      }
      return this;
    }
    removeAll() {
      this.splice(0, this.length);
      return this;
    }
    exists(node) {
      return this.includes(node);
    }
    first() {
      return this.at(0);
    }
    get(position) {
      const indexedNodes = [...this.values()];
      const value = indexedNodes.at(position);
      if (!value) {
        throw new RangeError(`The index ${position} does not exists`);
      }
      return value;
    }
    firstNodeWithName(nodeName) {
      return this.find((node) => node.name() === nodeName);
    }
    getNodesByName(nodeName) {
      const nodes = new _Nodes();
      for (const node of this) {
        if (node.name() === nodeName) {
          nodes.add(node);
        }
      }
      return nodes;
    }
    importFromArray(nodes) {
      for (const [index, node] of nodes.entries()) {
        if (typeof node.searchNodes !== "function" || typeof node.children !== "function") {
          throw new SyntaxError(`The element index ${index} is not a NodeInterface object`);
        }
      }
      this.add(...nodes);
      return this;
    }
  };

  // src/nodes/node.ts
  var Node = class {
    _name;
    _attributes;
    _children;
    _value;
    constructor(name, attributes = {}, children = [], value = "") {
      if (!Xml.isValidXmlName(name)) {
        throw new SyntaxError(`Cannot create a node with an invalid xml name: ${name}`);
      }
      this._name = name;
      this._attributes = new Attributes(attributes);
      this._children = new Nodes(children);
      this._value = value;
    }
    name() {
      return this._name;
    }
    children() {
      return this._children;
    }
    addChild(node) {
      this._children.add(node);
      return node;
    }
    attributes() {
      return this._attributes;
    }
    clear() {
      this._attributes.clear();
      this._children.removeAll();
    }
    addAttributes(attributes) {
      this._attributes.importRecord(attributes);
    }
    value() {
      return this._value;
    }
    setValue(value) {
      this._value = value;
    }
    searchAttribute(...searchPath) {
      const attribute = searchPath.pop();
      const node = this.searchNode(...searchPath);
      if (!node || !attribute) {
        return "";
      }
      return node.attributes().get(attribute) || "";
    }
    searchNodes(...searchPath) {
      const nodes = new Nodes();
      const nodeName = searchPath.pop();
      const parent = this.searchNode(...searchPath);
      if (parent) {
        for (const child of parent.children()) {
          if (child.name() === nodeName) {
            nodes.add(child);
          }
        }
      }
      return nodes;
    }
    searchNode(...searchPath) {
      let node = this;
      for (const searchName of searchPath) {
        node = node.children().firstNodeWithName(searchName);
        if (!node) {
          break;
        }
      }
      return node;
    }
    /**
     * Array access implementation as attribute helpers
     */
    offsetExists(offset) {
      return this.attributes().offsetExists(offset);
    }
    get(offset) {
      return this.attributes().offsetGet(offset);
    }
    set(offset, value) {
      this.attributes().offsetSet(offset, value);
    }
    unset(offset) {
      this.attributes().offsetUnset(offset);
    }
    count() {
      return this.children().length;
    }
    [Symbol.iterator]() {
      return this._children[Symbol.iterator]();
    }
  };

  // src/nodes/xml-node-exporter.ts
  var XmlNodeExporter = class {
    export(node) {
      const document = Xml.newDocument();
      const rootElement = this.exportRecursive(document, node);
      document.appendChild(rootElement);
      return rootElement;
    }
    exportRecursive(document, node) {
      const element = document.createElement(node.name());
      for (const [key, value] of node.attributes().entries()) {
        element.setAttribute(key, value);
      }
      for (const child of node.children()) {
        const childElement = this.exportRecursive(document, child);
        element.appendChild(childElement);
      }
      if (this.isNodeHasValueInterface(node) && node.value() !== "") {
        element.appendChild(document.createTextNode(node.value()));
      }
      return element;
    }
    isNodeHasValueInterface(nodo) {
      return typeof nodo.value === "function" && typeof nodo.setValue === "function";
    }
  };

  // src/nodes/xml-node-importer.ts
  var XmlNodeImporter = class {
    /**
     * Local record for registered namespaces to avoid set the namespace declaration in every child
     */
    registeredNamespaces = {};
    import(element) {
      const node = new Node(element.tagName);
      node.setValue(this.extractValue(element));
      if (element.prefix && element.prefix !== "") {
        this.registerNamespace(node, `xmlns:${element.prefix}`, element.namespaceURI);
        this.registerNamespace(node, `xmlns:xsi`, "http://www.w3.org/2001/XMLSchema-instance");
      }
      for (const attribute of Array.from(element.attributes)) {
        node.attributes().set(attribute.name, attribute.value);
      }
      if (element.hasAttributeNS("http://www.w3.org/2000/xmlns/", "")) {
        node.attributes().set("xmlns", element.getAttributeNS("http://www.w3.org/2000/xmlns/", ""));
      }
      for (const children of Array.from(element.childNodes)) {
        if (!DomValidators.isElement(children)) {
          continue;
        }
        const childNode = this.import(children);
        node.children().add(childNode);
      }
      return node;
    }
    registerNamespace(node, prefix, uri) {
      if (this.registeredNamespaces[prefix]) {
        return;
      }
      this.registeredNamespaces[prefix] = uri;
      node.attributes().set(prefix, uri);
    }
    extractValue(element) {
      const values = [];
      for (const children of Array.from(element.childNodes)) {
        if (!DomValidators.isText(children)) {
          continue;
        }
        values.push(children.data);
      }
      return values.join("");
    }
  };

  // src/nodes/xml-node-utils.ts
  var XmlNodeUtils = {
    nodeToXmlElement(node) {
      return new XmlNodeExporter().export(node);
    },
    nodeToXmlString(node, withXmlHeader = false) {
      const element = XmlNodeUtils.nodeToXmlElement(node);
      if (withXmlHeader) {
        const document = element.ownerDocument;
        const pi = document.createProcessingInstruction("xml", 'version="1.0" encoding="UTF-8"');
        document.insertBefore(pi, document.firstChild);
        return getSerializer().serializeToString(document);
      }
      return getSerializer().serializeToString(element.ownerDocument);
    },
    nodeFromXmlElement(element) {
      return new XmlNodeImporter().import(element);
    },
    nodeFromXmlString(content) {
      return XmlNodeUtils.nodeFromXmlElement(Xml.documentElement(Xml.newDocumentContent(content)));
    }
  };

  // src/utils/currency-decimals.ts
  var CurrencyDecimals = class _CurrencyDecimals {
    static decimalsCount(value) {
      const values = value.split(".");
      const decimals = values.length > 1 ? values.at(-1) : void 0;
      return decimals ? decimals.length : 0;
    }
    static newFromKnownCurrencies(currency, defaultValue) {
      let decimals = _CurrencyDecimals.knownCurrencyDecimals(currency);
      if (decimals < 0) {
        if (!defaultValue) {
          throw new RangeError(`The currency ${currency} is not known`);
        }
        decimals = defaultValue;
      }
      return new _CurrencyDecimals(currency, decimals);
    }
    static knownCurrencyDecimals(currency) {
      const map = {
        MXN: 2,
        EUR: 2,
        USD: 2,
        XXX: 0
      };
      return map[currency] || -1;
    }
    _currency;
    _decimals;
    constructor(currency, decimals) {
      if (!/^[A-Z]{3}$/.test(currency)) {
        throw new Error("Property currency is not valid");
      }
      if (decimals < 0) {
        throw new Error("Property decimals cannot be less than zero");
      }
      this._currency = currency;
      this._decimals = Math.floor(decimals);
    }
    currency() {
      return this._currency;
    }
    decimals() {
      return this._decimals;
    }
    round(value) {
      return Number.parseFloat(value.toFixed(this.decimals()));
    }
    doesNotExceedDecimals(value) {
      return _CurrencyDecimals.decimalsCount(value) <= this.decimals();
    }
  };
  /* istanbul ignore else -- @preserve */
  /* istanbul ignore next -- @preserve */
  /* istanbul ignore if -- @preserve Hard of test */

  exports.Attributes = Attributes;
  exports.CurrencyDecimals = CurrencyDecimals;
  exports.DomNotFoundError = DomNotFoundError;
  exports.DomValidators = DomValidators;
  exports.Node = Node;
  exports.Nodes = Nodes;
  exports.NodesSorter = NodesSorter;
  exports.Xml = Xml;
  exports.XmlNodeUtils = XmlNodeUtils;
  exports.getDom = getDom;
  exports.getParser = getParser;
  exports.getSerializer = getSerializer;
  exports.install = install;

  return exports;

})({});
