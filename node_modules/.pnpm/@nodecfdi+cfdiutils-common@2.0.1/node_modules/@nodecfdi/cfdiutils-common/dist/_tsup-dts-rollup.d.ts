declare class Attributes extends Map<string, string> {
    /**
     * Cast any value to string
     */
    private static castValueToString;
    constructor(attributes?: Record<string, unknown>);
    get(name: string): string;
    set(name: string, value?: string | null): this;
    exists(name: string): boolean;
    importRecord(attributes: Record<string, unknown>): this;
    exportRecord(): Record<string, string>;
    /**
     * Array access implementation as attribute helpers
     */
    offsetExists(offset: string): boolean;
    offsetGet(offset: string): string;
    offsetSet(offset: string, value?: unknown): void;
    offsetUnset(offset: string): void;
}
export { Attributes }
export { Attributes as Attributes_alias_1 }

/**
 * Currency Helper utility for parse string to number with currency value.
 */
declare class CurrencyDecimals {
    static decimalsCount(value: string): number;
    static newFromKnownCurrencies(currency: string, defaultValue?: number): CurrencyDecimals;
    static knownCurrencyDecimals(currency: string): number;
    private readonly _currency;
    private readonly _decimals;
    constructor(currency: string, decimals: number);
    currency(): string;
    decimals(): number;
    round(value: number): number;
    doesNotExceedDecimals(value: string): boolean;
}
export { CurrencyDecimals }
export { CurrencyDecimals as CurrencyDecimals_alias_1 }

/**
 * DOMNotFoundError exception. For not provided dom resolver.
 */
declare class DomNotFoundError extends Error {
    constructor(type: 'DOMParser' | 'XMLSerializer' | 'DOMImplementation');
}
export { DomNotFoundError }
export { DomNotFoundError as DomNotFoundError_alias_1 }

/**
 * DOM validators for compare node elements.
 */
declare const DomValidators: {
    isElement(nodo?: Node): nodo is Element;
    isAttr(nodo?: Node): nodo is Attr;
    isText(nodo?: Node): nodo is Text;
    isDocument(nodo?: Node): nodo is Document;
};
export { DomValidators }
export { DomValidators as DomValidators_alias_1 }

/**
 * Get instance of DOMImplementation
 *
 * @returns the current DOMImplementation object
 *
 * @throws {@link DomNotFoundError} This exception is throw if not install DOMImplementation.
 */
declare const getDom: () => DOMImplementation;
export { getDom }
export { getDom as getDom_alias_1 }

/**
 * Get instance of DOMParser
 *
 * @returns the current DOMParser object
 *
 * @throws {@link DomNotFoundError} This exception is throw if not install DOMParser.
 */
declare const getParser: () => DOMParser;
export { getParser }
export { getParser as getParser_alias_1 }

/**
 * Get instance of XMLSerializer
 *
 * @returns the current XMLSerializer object
 *
 * @throws {@link DomNotFoundError} This exception is throw if not install XMLSerializer.
 */
declare const getSerializer: () => XMLSerializer;
export { getSerializer }
export { getSerializer as getSerializer_alias_1 }

/**
 * Install DOM instances for usage on this library
 */
declare const install: (parser?: DOMParser, serializer?: XMLSerializer, dom?: DOMImplementation) => void;
export { install }
export { install as install_alias_1 }

declare class Node_2 implements NodeInterface, NodeHasValueInterface {
    private readonly _name;
    private readonly _attributes;
    private readonly _children;
    private _value;
    constructor(name: string, attributes?: Record<string, unknown>, children?: NodeInterface[], value?: string);
    name(): string;
    children(): Nodes;
    addChild(node: NodeInterface): NodeInterface;
    attributes(): Attributes;
    clear(): void;
    addAttributes(attributes: Record<string, unknown>): void;
    value(): string;
    setValue(value: string): void;
    searchAttribute(...searchPath: string[]): string;
    searchNodes(...searchPath: string[]): Nodes;
    searchNode(...searchPath: string[]): NodeInterface | undefined;
    /**
     * Array access implementation as attribute helpers
     */
    offsetExists(offset: string): boolean;
    get(offset: string): string;
    set(offset: string, value: unknown): void;
    unset(offset: string): void;
    count(): number;
    [Symbol.iterator](): IterableIterator<NodeInterface>;
}
export { Node_2 as Node }
export { Node_2 as Node_alias_1 }

declare type NodeHasValueInterface = {
    value(): string;
    setValue(value: string): void;
};
export { NodeHasValueInterface }
export { NodeHasValueInterface as NodeHasValueInterface_alias_1 }

declare type NodeInterface = {
    name(): string;
    children(): Nodes;
    addChild(node: NodeInterface): NodeInterface;
    attributes(): Attributes;
    addAttributes(attributes: Record<string, unknown>): void;
    clear(): void;
    searchAttribute(...searchPath: string[]): string;
    searchNodes(...searchPath: string[]): Nodes;
    searchNode(...searchPath: string[]): NodeInterface | undefined;
    offsetExists(offset: string): boolean;
    get(offset: string): string;
    set(offset: string, value: string): void;
    unset(offset: string): void;
    count(): number;
    [Symbol.iterator](): IterableIterator<NodeInterface>;
};
export { NodeInterface }
export { NodeInterface as NodeInterface_alias_1 }

declare class Nodes extends Array<NodeInterface> {
    private readonly _sorter;
    constructor(nodes?: NodeInterface[]);
    static get [Symbol.species](): ArrayConstructor;
    add(...nodes: NodeInterface[]): this;
    order(): void;
    /**
     * It takes only the unique string names and sort using the order of appearance
     * @param names - names for order
     */
    setOrder(names: string[]): void;
    getOrder(): string[];
    remove(node: NodeInterface): this;
    removeAll(): this;
    exists(node: NodeInterface): boolean;
    first(): NodeInterface | undefined;
    get(position: number): NodeInterface;
    firstNodeWithName(nodeName: string): NodeInterface | undefined;
    getNodesByName(nodeName: string): Nodes;
    importFromArray(nodes: NodeInterface[]): this;
}
export { Nodes }
export { Nodes as Nodes_alias_1 }

declare class NodesSorter {
    /**
     * Internal compare Maps
     * @param a - map
     * @param b - map
     */
    private static compareMaps;
    private _order;
    private size;
    constructor(order?: string[]);
    /**
     * It takes only the unique strings names and sort using the order of appearance
     * @param names - unique strings
     */
    setOrder(names: string[]): boolean;
    parseNames(names: unknown[]): Map<number, string>;
    /**
     * The current order list
     */
    getOrder(): string[];
    sort(nodes: NodeInterface[]): NodeInterface[];
    compareNodesByName(a: NodeInterface, b: NodeInterface): number;
    valueByName(name: string): number;
    /**
     * This function is a replacement for sort that try to sort
     * but if items are equal then uses the relative position as second argument
     * @param input - NodeInterface
     * @param callable - function callable
     */
    private stableArraySort;
}
export { NodesSorter }
export { NodesSorter as NodesSorter_alias_1 }

/**
 * XML static utils
 */
declare const Xml: {
    documentElement(document: Document): Element;
    ownerDocument(node: Node): Document;
    newDocument(document?: Document): Document;
    newDocumentContent(content: string): Document;
    isValidXmlName(name: string): boolean;
    createElement(document: Document, name: string, content?: string): Element;
    createDomElement(makeElement: () => Element, errorMessage: string, content: string): Element;
};
export { Xml }
export { Xml as Xml_alias_1 }

export declare class XmlNodeExporter {
    export(node: NodeInterface): Element;
    private exportRecursive;
    private isNodeHasValueInterface;
}

export declare class XmlNodeImporter {
    /**
     * Local record for registered namespaces to avoid set the namespace declaration in every child
     */
    private registeredNamespaces;
    import(element: Element): NodeInterface & NodeHasValueInterface;
    private registerNamespace;
    private extractValue;
}

declare const XmlNodeUtils: {
    nodeToXmlElement(node: NodeInterface): Element;
    nodeToXmlString(node: NodeInterface, withXmlHeader?: boolean): string;
    nodeFromXmlElement(element: Element): NodeInterface & NodeHasValueInterface;
    nodeFromXmlString(content: string): NodeInterface & NodeHasValueInterface;
};
export { XmlNodeUtils }
export { XmlNodeUtils as XmlNodeUtils_alias_1 }

export { }
