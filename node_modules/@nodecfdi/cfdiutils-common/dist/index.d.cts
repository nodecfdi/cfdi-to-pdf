/**
 * Get instance of DOMParser
 *
 * @returns the current DOMParser object
 *
 * @throws {@link DOMNotFoundError} This exception is throw if not install DOMParser.
 */
declare const getParser: () => DOMParser;
/**
 * Get instance of XMLSerializer
 *
 * @returns the current XMLSerializer object
 *
 * @throws {@link DOMNotFoundError} This exception is throw if not install XMLSerializer.
 */
declare const getSerializer: () => XMLSerializer;
/**
 * Get instance of DOMImplementation
 *
 * @returns the current DOMImplementation object
 *
 * @throws {@link DOMNotFoundError} This exception is throw if not install DOMImplementation.
 */
declare const getDom: () => DOMImplementation;
/**
 * Install DOM instances for usage on this library
 */
declare const install: (parser?: DOMParser, serializer?: XMLSerializer, dom?: DOMImplementation) => void;

/**
 * DOMNotFoundError exception. For not provided dom resolver.
 */
declare class DOMNotFoundError extends Error {
    /**
     *
     */
    constructor(type: 'DOMParser' | 'XMLSerializer' | 'DOMImplementation');
}

declare class CAttributes extends Map<string, string> {
    constructor(attributes?: Record<string, unknown>);
    /**
     * Cast any value to string
     */
    private static castValueToString;
    get(name: string): string;
    set(name: string, value?: string | null): this;
    exists(name: string): boolean;
    importRecord(attributes: Record<string, unknown>): this;
    exportRecord(): Record<string, string>;
    /**
     * Array access implementation as attribute helpers
     */
    offsetExists(offset: string): boolean;
    offsetGet(offset: string): string;
    offsetSet(offset: string, value?: unknown): void;
    offsetUnset(offset: string): void;
}

type CNodeHasValueInterface = {
    value(): string;
    setValue(value: string): void;
};

declare class CNodes extends Array<CNodeInterface> {
    private readonly _sorter;
    constructor(nodes?: CNodeInterface[]);
    static get [Symbol.species](): ArrayConstructor;
    add(...nodes: CNodeInterface[]): this;
    order(): void;
    /**
     * It takes only the unique string names and sort using the order of appearance
     * @param names - names for order
     */
    setOrder(names: string[]): void;
    getOrder(): string[];
    remove(node: CNodeInterface): this;
    removeAll(): this;
    exists(node: CNodeInterface): boolean;
    first(): CNodeInterface | undefined;
    get(position: number): CNodeInterface;
    firstNodeWithName(nodeName: string): CNodeInterface | undefined;
    getNodesByName(nodeName: string): CNodes;
    importFromArray(nodes: CNodeInterface[]): this;
}

type CNodeInterface = {
    name(): string;
    children(): CNodes;
    addChild(node: CNodeInterface): CNodeInterface;
    attributes(): CAttributes;
    addAttributes(attributes: Record<string, unknown>): void;
    clear(): void;
    searchAttribute(...searchPath: string[]): string;
    searchNodes(...searchPath: string[]): CNodes;
    searchNode(...searchPath: string[]): CNodeInterface | undefined;
    offsetExists(offset: string): boolean;
    get(offset: string): string;
    set(offset: string, value: string): void;
    unset(offset: string): void;
    count(): number;
    [Symbol.iterator](): IterableIterator<CNodeInterface>;
};

declare class CNode implements CNodeInterface, CNodeHasValueInterface {
    private readonly _name;
    private readonly _attributes;
    private readonly _children;
    private _value;
    constructor(name: string, attributes?: Record<string, unknown>, children?: CNodeInterface[], value?: string);
    name(): string;
    children(): CNodes;
    addChild(node: CNodeInterface): CNodeInterface;
    attributes(): CAttributes;
    clear(): void;
    addAttributes(attributes: Record<string, unknown>): void;
    value(): string;
    setValue(value: string): void;
    searchAttribute(...searchPath: string[]): string;
    searchNodes(...searchPath: string[]): CNodes;
    searchNode(...searchPath: string[]): CNodeInterface | undefined;
    /**
     * Array access implementation as attribute helpers
     */
    offsetExists(offset: string): boolean;
    get(offset: string): string;
    set(offset: string, value: unknown): void;
    unset(offset: string): void;
    count(): number;
    [Symbol.iterator](): IterableIterator<CNodeInterface>;
}

declare class CNodesSorter {
    private _order;
    private size;
    constructor(order?: string[]);
    /**
     * Internal compare Maps
     * @param a - map
     * @param b - map
     */
    private static compareMaps;
    /**
     * It takes only the unique strings names and sort using the order of appearance
     * @param names - unique strings
     */
    setOrder(names: string[]): boolean;
    parseNames(names: unknown[]): Map<number, string>;
    /**
     * The current order list
     */
    getOrder(): string[];
    sort(nodes: CNodeInterface[]): CNodeInterface[];
    compareNodesByName(a: CNodeInterface, b: CNodeInterface): number;
    valueByName(name: string): number;
    /**
     * This function is a replacement for sort that try to sort
     * but if items are equal then uses the relative position as second argument
     * @param input - CNodeInterface
     * @param callable - function callable
     */
    private stableArraySort;
}

declare const XmlNodeUtils: {
    nodeToXmlElement(node: CNodeInterface): Element;
    nodeToXmlString(node: CNodeInterface, withXmlHeader?: boolean): string;
    nodeFromXmlElement(element: Element): CNodeInterface & CNodeHasValueInterface;
    nodeFromXmlString(content: string): CNodeInterface & CNodeHasValueInterface;
};

/**
 * Currency Helper utility for parse string to number with currency value.
 */
declare class CurrencyDecimals {
    private readonly _currency;
    private readonly _decimals;
    constructor(currency: string, decimals: number);
    static decimalsCount(value: string): number;
    static newFromKnownCurrencies(currency: string, defaultValue?: number): CurrencyDecimals;
    static knownCurrencyDecimals(currency: string): number;
    currency(): string;
    decimals(): number;
    round(value: number): number;
    doesNotExceedDecimals(value: string): boolean;
}

/**
 * DOM validators for compare node elements.
 */
declare const DomValidators: {
    isElement(nodo?: Node): nodo is Element;
    isAttr(nodo?: Node): nodo is Attr;
    isText(nodo?: Node): nodo is Text;
    isDocument(nodo?: Node): nodo is Document;
};

/**
 * XML static utils
 */
declare const Xml: {
    documentElement(document: Document): Element;
    ownerDocument(node: Node): Document;
    newDocument(document?: Document): Document;
    newDocumentContent(content: string): Document;
    isValidXmlName(name: string): boolean;
    createElement(document: Document, name: string, content?: string): Element;
    createDOMElement(makeElement: () => Element, errorMessage: string, content: string): Element;
};

export { CAttributes, CNode, CNodeHasValueInterface, CNodeInterface, CNodes, CNodesSorter, CurrencyDecimals, DOMNotFoundError, DomValidators, Xml, XmlNodeUtils, getDom, getParser, getSerializer, install };
