{"version":3,"sources":["../src/index.ts","../src/exceptions/dom-not-found-error.ts","../src/dom.ts","../src/utils/dom-validators.ts","../src/utils/xml.ts","../src/nodes/c-attributes.ts","../src/nodes/c-nodes-sorter.ts","../src/nodes/c-nodes.ts","../src/nodes/c-node.ts","../src/nodes/xml-node-exporter.ts","../src/nodes/xml-node-importer.ts","../src/nodes/xml-node-utils.ts","../src/utils/currency-decimals.ts"],"sourcesContent":["// Copyright (c) Nodecfdi. All rights reserved. Licensed under the MIT license.\n\n/**\n * A library for structures of common data and utils or functions on suit cfdiutils.\n */\nexport * from './dom';\nexport * from './exceptions/dom-not-found-error';\nexport * from './nodes/c-attributes';\nexport * from './nodes/c-node';\nexport * from './nodes/c-node-has-value-interface';\nexport * from './nodes/c-node-interface';\nexport * from './nodes/c-nodes';\nexport * from './nodes/c-nodes-sorter';\nexport * from './nodes/xml-node-utils';\nexport * from './utils/currency-decimals';\nexport * from './utils/dom-validators';\nexport * from './utils/xml';\n","/**\n * DOMNotFoundError exception. For not provided dom resolver.\n */\nexport class DOMNotFoundError extends Error {\n    /**\n     *\n     */\n    constructor(type: 'DOMParser' | 'XMLSerializer' | 'DOMImplementation') {\n        super(`No ${type} was provided.`);\n        this.name = `${type}NotFoundError`;\n    }\n}\n","import { DOMNotFoundError } from './exceptions/dom-not-found-error';\n\nlet _dom: DOMImplementation | undefined;\nlet _parser: DOMParser | undefined;\nlet _serializer: XMLSerializer | undefined;\n\n/**\n * Get instance of DOMParser\n *\n * @returns the current DOMParser object\n *\n * @throws {@link DOMNotFoundError} This exception is throw if not install DOMParser.\n */\nconst getParser = (): DOMParser => {\n    if (!_parser) {\n        throw new DOMNotFoundError('DOMParser');\n    }\n\n    return _parser;\n};\n\n/**\n * Get instance of XMLSerializer\n *\n * @returns the current XMLSerializer object\n *\n * @throws {@link DOMNotFoundError} This exception is throw if not install XMLSerializer.\n */\nconst getSerializer = (): XMLSerializer => {\n    if (!_serializer) {\n        throw new DOMNotFoundError('XMLSerializer');\n    }\n\n    return _serializer;\n};\n\n/**\n * Get instance of DOMImplementation\n *\n * @returns the current DOMImplementation object\n *\n * @throws {@link DOMNotFoundError} This exception is throw if not install DOMImplementation.\n */\nconst getDom = (): DOMImplementation => {\n    if (!_dom) {\n        throw new DOMNotFoundError('DOMImplementation');\n    }\n\n    return _dom;\n};\n\n/**\n * Install DOM instances for usage on this library\n */\nconst install = (parser?: DOMParser, serializer?: XMLSerializer, dom?: DOMImplementation): void => {\n    _parser = parser;\n    _serializer = serializer;\n    _dom = dom;\n};\n\nexport { getParser, getSerializer, getDom, install };\n","/**\n * DOM validators for compare node elements.\n */\nexport const DomValidators = {\n    isElement(nodo?: Node): nodo is Element {\n        return Boolean(nodo && nodo.nodeType === nodo.ELEMENT_NODE);\n    },\n\n    isAttr(nodo?: Node): nodo is Attr {\n        return Boolean(nodo && nodo.nodeType === nodo.ATTRIBUTE_NODE);\n    },\n\n    isText(nodo?: Node): nodo is Text {\n        return Boolean(nodo && nodo.nodeType === nodo.TEXT_NODE);\n    },\n\n    isDocument(nodo?: Node): nodo is Document {\n        return Boolean(nodo && nodo.nodeType === nodo.DOCUMENT_NODE);\n    },\n};\n","import { getDom, getParser } from '../dom';\nimport { DomValidators } from './dom-validators';\n\n/**\n * XML static utils\n */\nexport const Xml = {\n    documentElement(document: Document): Element {\n        if (!DomValidators.isElement(document.documentElement)) {\n            throw new SyntaxError('Document does not have root element');\n        }\n\n        return document.documentElement;\n    },\n\n    ownerDocument(node: Node): Document {\n        if (!node.ownerDocument) {\n            /* istanbul ignore else -- @preserve */\n            if (DomValidators.isDocument(node)) {\n                return node;\n            }\n\n            /* istanbul ignore next -- @preserve */\n            throw new TypeError('node.ownerDocument is undefined but node is not a Document');\n        }\n\n        return node.ownerDocument;\n    },\n\n    newDocument(document?: Document): Document {\n        if (!document) {\n            document = getDom().createDocument(null, null, null);\n        }\n\n        return document;\n    },\n\n    newDocumentContent(content: string): Document {\n        if (content === '') {\n            throw new SyntaxError('Received xml string argument is empty');\n        }\n\n        const parser = getParser();\n        try {\n            const documentParse = parser.parseFromString(content, 'text/xml');\n\n            // eslint-disable-next-line unicorn/prefer-query-selector\n            if (documentParse.getElementsByTagName('parsererror').length > 0) {\n                throw new Error('Error parsing XML');\n            }\n\n            return Xml.newDocument(documentParse);\n        } catch (error) {\n            throw new SyntaxError(`Cannot create a Document from xml string, errors: ${JSON.stringify(error)}`);\n        }\n    },\n\n    isValidXmlName(name: string): boolean {\n        if (name === '') {\n            return false;\n        }\n\n        return /^[\\p{L}_:][\\p{L}\\d_:.-]*$/u.test(name);\n    },\n\n    createElement(document: Document, name: string, content = ''): Element {\n        return Xml.createDOMElement(\n            () => {\n                if (!name) {\n                    throw new SyntaxError('Empty Name');\n                }\n\n                return document.createElement(name);\n            },\n            `Cannot create element with name ${name}`,\n            content,\n        );\n    },\n\n    createDOMElement(makeElement: () => Element, errorMessage: string, content: string): Element {\n        let element: Element | undefined;\n        let previousException: Error | undefined;\n        try {\n            element = makeElement();\n        } catch (error) {\n            previousException = error as Error;\n        }\n\n        if (!element || !DomValidators.isElement(element)) {\n            throw new SyntaxError(\n                `${errorMessage} on ${previousException ? previousException.message : 'not is element'}`,\n            );\n        }\n\n        if (content !== '') {\n            element.appendChild(Xml.ownerDocument(element).createTextNode(content));\n        }\n\n        return element;\n    },\n};\n","import { Xml } from '../utils/xml';\n\nexport class CAttributes extends Map<string, string> {\n    constructor(attributes: Record<string, unknown> = {}) {\n        super();\n        this.importRecord(attributes);\n    }\n\n    /**\n     * Cast any value to string\n     */\n    private static castValueToString(key: string, value: unknown): undefined | string {\n        if (value === null || value === undefined) {\n            return undefined;\n        }\n\n        if (/boolean|number|string/.test(typeof value)) {\n            return `${value as boolean | number | string}`;\n        }\n\n        if (typeof value === 'object' && !Array.isArray(value)) {\n            return (value as { toString: () => string }).toString();\n        }\n\n        throw new SyntaxError(`Cannot convert value of attribute ${key} to string`);\n    }\n\n    public override get(name: string): string {\n        const value = super.get(name);\n\n        if (value === undefined) {\n            return '';\n        }\n\n        return value;\n    }\n\n    public override set(name: string, value?: string | null): this {\n        if (value === undefined || value === null) {\n            this.delete(name);\n\n            return this;\n        }\n\n        if (!Xml.isValidXmlName(name)) {\n            throw new SyntaxError(`Cannot set attribute with an invalid xml name: ${name}`);\n        }\n\n        super.set(name, value.toString());\n\n        return this;\n    }\n\n    public exists(name: string): boolean {\n        let found = false;\n        for (const key of this.keys()) {\n            if (name === key) {\n                found = true;\n                break;\n            }\n        }\n\n        return found;\n    }\n\n    public importRecord(attributes: Record<string, unknown>): this {\n        if (Object.keys(attributes).length > 0) {\n            for (const [key, value] of Object.entries(attributes)) {\n                const fixedValue = CAttributes.castValueToString(key, value);\n                this.set(key, fixedValue);\n            }\n        }\n\n        return this;\n    }\n\n    public exportRecord(): Record<string, string> {\n        const jsonResponse: Record<string, string> = {};\n        for (const [key, value] of this.entries()) {\n            jsonResponse[key] = value;\n        }\n\n        return jsonResponse;\n    }\n\n    /**\n     * Array access implementation as attribute helpers\n     */\n    public offsetExists(offset: string): boolean {\n        return this.exists(offset);\n    }\n\n    public offsetGet(offset: string): string {\n        return this.get(offset);\n    }\n\n    public offsetSet(offset: string, value?: unknown): void {\n        this.set(offset, CAttributes.castValueToString(offset, value));\n    }\n\n    public offsetUnset(offset: string): void {\n        super.delete(offset);\n    }\n}\n","import { type CNodeInterface } from './c-node-interface';\n\nexport class CNodesSorter {\n    private _order: Map<string, number> = new Map<string, number>();\n\n    private size!: number;\n\n    constructor(order: string[] = []) {\n        this.setOrder(order);\n    }\n\n    /**\n     * Internal compare Maps\n     * @param a - map\n     * @param b - map\n     */\n    private static compareMaps(a: Map<unknown, unknown>, b: Map<unknown, unknown>): boolean {\n        let testValue;\n        if (a.size !== b.size) {\n            return false;\n        }\n\n        for (const [key, value] of a) {\n            testValue = b.get(key);\n            if (testValue !== value || (testValue === undefined && !b.has(key))) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    /**\n     * It takes only the unique strings names and sort using the order of appearance\n     * @param names - unique strings\n     */\n    public setOrder(names: string[]): boolean {\n        const order = new Map(Array.from(this.parseNames(names), (entry) => [entry[1], entry[0]]));\n        if (CNodesSorter.compareMaps(this._order, order)) {\n            return false;\n        }\n\n        this._order = order;\n        this.size = order.size;\n\n        return true;\n    }\n\n    public parseNames(names: unknown[]): Map<number, string> {\n        const isValidName = (name: unknown): boolean => Boolean(name) && typeof name === 'string' && name !== '0';\n\n        return new Map(\n            [...new Set(names.filter((element) => isValidName(element)) as string[])].map((entry, index) => [\n                index,\n                entry,\n            ]),\n        );\n    }\n\n    /**\n     * The current order list\n     */\n    public getOrder(): string[] {\n        const flippedArray = new Map(Array.from(this._order, (entry) => [entry[1], entry[0]]));\n\n        return [...flippedArray.values()];\n    }\n\n    public sort(nodes: CNodeInterface[]): CNodeInterface[] {\n        if (this.size > 0) {\n            nodes = this.stableArraySort(nodes, 'compareNodesByName');\n        }\n\n        return nodes;\n    }\n\n    public compareNodesByName(a: CNodeInterface, b: CNodeInterface): number {\n        const aNumber = this.valueByName(a.name());\n        const bNumber = this.valueByName(b.name());\n\n        return Math.sign(aNumber - bNumber);\n    }\n\n    public valueByName(name: string): number {\n        const getOrder = this._order.get(name);\n\n        return getOrder ?? this.size;\n    }\n\n    /**\n     * This function is a replacement for sort that try to sort\n     * but if items are equal then uses the relative position as second argument\n     * @param input - CNodeInterface\n     * @param callable - function callable\n     */\n    private stableArraySort(input: CNodeInterface[], callable: keyof this): CNodeInterface[] {\n        let list = input.map((entry, index) => ({\n            item: entry,\n            index,\n        }));\n\n        // Double check by function provider and indexed\n        const comparar = (\n            a: { item: CNodeInterface; index: number },\n            b: { item: CNodeInterface; index: number },\n        ): number => {\n            let value: number = (this[callable] as (a: CNodeInterface, b: CNodeInterface) => number)(a.item, b.item);\n            if (value === 0) {\n                value = Math.sign(a.index - b.index);\n            }\n\n            return value;\n        };\n\n        list = list.sort(comparar);\n\n        return list.map((node) => node.item);\n    }\n}\n","import { type CNodeInterface } from './c-node-interface';\nimport { CNodesSorter } from './c-nodes-sorter';\n\nexport class CNodes extends Array<CNodeInterface> {\n    private readonly _sorter: CNodesSorter;\n\n    constructor(nodes: CNodeInterface[] = []) {\n        super();\n        this._sorter = new CNodesSorter();\n        this.importFromArray(nodes);\n    }\n\n    public static get [Symbol.species](): ArrayConstructor {\n        return Array;\n    }\n\n    public add(...nodes: CNodeInterface[]): this {\n        let somethingChange = false;\n        for (const node of nodes) {\n            if (!this.exists(node)) {\n                this.push(node);\n                somethingChange = true;\n            }\n        }\n\n        if (somethingChange) {\n            this.order();\n        }\n\n        return this;\n    }\n\n    public order(): void {\n        this.splice(0, this.length, ...this._sorter.sort(this));\n    }\n\n    /**\n     * It takes only the unique string names and sort using the order of appearance\n     * @param names - names for order\n     */\n    public setOrder(names: string[]): void {\n        if (this._sorter.setOrder(names)) {\n            this.order();\n        }\n    }\n\n    public getOrder(): string[] {\n        return this._sorter.getOrder();\n    }\n\n    public remove(node: CNodeInterface): this {\n        const index = this.indexOf(node);\n        if (index >= 0) {\n            this.splice(index, 1);\n        }\n\n        return this;\n    }\n\n    public removeAll(): this {\n        this.splice(0, this.length);\n\n        return this;\n    }\n\n    public exists(node: CNodeInterface): boolean {\n        return this.includes(node);\n    }\n\n    public first(): CNodeInterface | undefined {\n        return this.at(0);\n    }\n\n    public get(position: number): CNodeInterface {\n        const indexedNodes = [...this.values()];\n        const value = indexedNodes.at(position);\n        if (!value) {\n            throw new RangeError(`The index ${position} does not exists`);\n        }\n\n        return value;\n    }\n\n    public firstNodeWithName(nodeName: string): CNodeInterface | undefined {\n        return this.find((node) => node.name() === nodeName);\n    }\n\n    public getNodesByName(nodeName: string): CNodes {\n        const nodes = new CNodes();\n        for (const node of this) {\n            if (node.name() === nodeName) {\n                nodes.add(node);\n            }\n        }\n\n        return nodes;\n    }\n\n    public importFromArray(nodes: CNodeInterface[]): this {\n        for (const [index, node] of nodes.entries()) {\n            if (typeof node.searchNodes !== 'function' || typeof node.children !== 'function') {\n                throw new SyntaxError(`The element index ${index} is not a CNodeInterface object`);\n            }\n        }\n\n        this.add(...nodes);\n\n        return this;\n    }\n}\n","import { Xml } from '../utils/xml';\nimport { CAttributes } from './c-attributes';\nimport { type CNodeHasValueInterface } from './c-node-has-value-interface';\nimport { type CNodeInterface } from './c-node-interface';\nimport { CNodes } from './c-nodes';\n\nexport class CNode implements CNodeInterface, CNodeHasValueInterface {\n    private readonly _name: string;\n\n    private readonly _attributes: CAttributes;\n\n    private readonly _children: CNodes;\n\n    private _value: string;\n\n    constructor(name: string, attributes: Record<string, unknown> = {}, children: CNodeInterface[] = [], value = '') {\n        if (!Xml.isValidXmlName(name)) {\n            throw new SyntaxError(`Cannot create a node with an invalid xml name: ${name}`);\n        }\n\n        this._name = name;\n        this._attributes = new CAttributes(attributes);\n        this._children = new CNodes(children);\n        this._value = value;\n    }\n\n    public name(): string {\n        return this._name;\n    }\n\n    public children(): CNodes {\n        return this._children;\n    }\n\n    public addChild(node: CNodeInterface): CNodeInterface {\n        this._children.add(node);\n\n        return node;\n    }\n\n    public attributes(): CAttributes {\n        return this._attributes;\n    }\n\n    public clear(): void {\n        this._attributes.clear();\n        this._children.removeAll();\n    }\n\n    public addAttributes(attributes: Record<string, unknown>): void {\n        this._attributes.importRecord(attributes);\n    }\n\n    public value(): string {\n        return this._value;\n    }\n\n    public setValue(value: string): void {\n        this._value = value;\n    }\n\n    public searchAttribute(...searchPath: string[]): string {\n        const attribute = searchPath.pop();\n        const node = this.searchNode(...searchPath);\n        if (!node || !attribute) {\n            return '';\n        }\n\n        return node.attributes().get(attribute) || '';\n    }\n\n    public searchNodes(...searchPath: string[]): CNodes {\n        const nodes = new CNodes();\n        const nodeName = searchPath.pop();\n        const parent = this.searchNode(...searchPath);\n        if (parent) {\n            for (const child of parent.children()) {\n                if (child.name() === nodeName) {\n                    nodes.add(child);\n                }\n            }\n        }\n\n        return nodes;\n    }\n\n    public searchNode(...searchPath: string[]): CNodeInterface | undefined {\n        // eslint-disable-next-line @typescript-eslint/no-this-alias, unicorn/no-this-assignment\n        let node: CNodeInterface | undefined = this;\n        for (const searchName of searchPath) {\n            node = node.children().firstNodeWithName(searchName);\n            if (!node) {\n                break;\n            }\n        }\n\n        return node;\n    }\n\n    /**\n     * Array access implementation as attribute helpers\n     */\n    public offsetExists(offset: string): boolean {\n        return this.attributes().offsetExists(offset);\n    }\n\n    public get(offset: string): string {\n        return this.attributes().offsetGet(offset);\n    }\n\n    public set(offset: string, value: unknown): void {\n        this.attributes().offsetSet(offset, value);\n    }\n\n    public unset(offset: string): void {\n        this.attributes().offsetUnset(offset);\n    }\n\n    public count(): number {\n        return this.children().length;\n    }\n\n    public [Symbol.iterator](): IterableIterator<CNodeInterface> {\n        return this._children[Symbol.iterator]();\n    }\n}\n","import { Xml } from '../utils/xml';\nimport { type CNodeHasValueInterface } from './c-node-has-value-interface';\nimport { type CNodeInterface } from './c-node-interface';\n\nexport class XmlNodeExporter {\n    public export(node: CNodeInterface): Element {\n        const document = Xml.newDocument();\n        const rootElement = this.exportRecursive(document, node);\n        document.appendChild(rootElement);\n\n        return rootElement;\n    }\n\n    private exportRecursive(document: Document, node: CNodeInterface): Element {\n        const element = document.createElement(node.name());\n\n        for (const [key, value] of node.attributes().entries()) {\n            element.setAttribute(key, value);\n        }\n\n        for (const child of node.children()) {\n            const childElement = this.exportRecursive(document, child);\n            element.appendChild(childElement);\n        }\n\n        if (this.isCNodeHasValueInterface(node) && node.value() !== '') {\n            element.appendChild(document.createTextNode(node.value()));\n        }\n\n        return element;\n    }\n\n    private isCNodeHasValueInterface(nodo: CNodeInterface | CNodeHasValueInterface): nodo is CNodeHasValueInterface {\n        return (\n            typeof (nodo as CNodeHasValueInterface).value === 'function' &&\n            typeof (nodo as CNodeHasValueInterface).setValue === 'function'\n        );\n    }\n}\n","import { DomValidators } from '../utils/dom-validators';\nimport { CNode } from './c-node';\nimport { type CNodeHasValueInterface } from './c-node-has-value-interface';\nimport { type CNodeInterface } from './c-node-interface';\n\nexport class XmlNodeImporter {\n    /**\n     * Local record for registered namespaces to avoid set the namespace declaration in every child\n     */\n    private registeredNamespaces: Record<string, string> = {};\n\n    public import(element: Element): CNodeInterface & CNodeHasValueInterface {\n        const node = new CNode(element.tagName);\n\n        node.setValue(this.extractValue(element));\n\n        if (element.prefix && element.prefix !== '') {\n            this.registerNamespace(node, `xmlns:${element.prefix}`, element.namespaceURI as string);\n            this.registerNamespace(node, `xmlns:xsi`, 'http://www.w3.org/2001/XMLSchema-instance');\n        }\n\n        // eslint-disable-next-line unicorn/prefer-spread\n        for (const attribute of Array.from(element.attributes)) {\n            node.attributes().set(attribute.name, attribute.value);\n        }\n\n        // Element is like <element namespace=\"uri\"/>\n        /* istanbul ignore if -- @preserve Hard of test */\n        if (element.hasAttributeNS('http://www.w3.org/2000/xmlns/', '')) {\n            node.attributes().set('xmlns', element.getAttributeNS('http://www.w3.org/2000/xmlns/', '') as string);\n        }\n\n        // eslint-disable-next-line unicorn/prefer-spread\n        for (const children of Array.from(element.childNodes)) {\n            if (!DomValidators.isElement(children)) {\n                continue;\n            }\n\n            const childNode = this.import(children);\n            node.children().add(childNode);\n        }\n\n        return node;\n    }\n\n    private registerNamespace(node: CNode, prefix: string, uri: string): void {\n        if (this.registeredNamespaces[prefix]) {\n            return;\n        }\n\n        this.registeredNamespaces[prefix] = uri;\n        node.attributes().set(prefix, uri);\n    }\n\n    private extractValue(element: Element): string {\n        const values: string[] = [];\n        // eslint-disable-next-line unicorn/prefer-spread\n        for (const children of Array.from(element.childNodes)) {\n            if (!DomValidators.isText(children)) {\n                continue;\n            }\n\n            values.push(children.data);\n        }\n\n        return values.join('');\n    }\n}\n","import { getSerializer } from '../dom';\nimport { Xml } from '../utils/xml';\nimport { type CNodeHasValueInterface } from './c-node-has-value-interface';\nimport { type CNodeInterface } from './c-node-interface';\nimport { XmlNodeExporter } from './xml-node-exporter';\nimport { XmlNodeImporter } from './xml-node-importer';\n\nexport const XmlNodeUtils = {\n    nodeToXmlElement(node: CNodeInterface): Element {\n        return new XmlNodeExporter().export(node);\n    },\n\n    nodeToXmlString(node: CNodeInterface, withXmlHeader = false): string {\n        const element = XmlNodeUtils.nodeToXmlElement(node);\n        if (withXmlHeader) {\n            const document = element.ownerDocument;\n            const pi = document.createProcessingInstruction('xml', 'version=\"1.0\" encoding=\"UTF-8\"');\n            document.insertBefore(pi, document.firstChild);\n\n            return getSerializer().serializeToString(document);\n        }\n\n        return getSerializer().serializeToString(element.ownerDocument);\n    },\n\n    nodeFromXmlElement(element: Element): CNodeInterface & CNodeHasValueInterface {\n        return new XmlNodeImporter().import(element);\n    },\n\n    nodeFromXmlString(content: string): CNodeInterface & CNodeHasValueInterface {\n        return XmlNodeUtils.nodeFromXmlElement(Xml.documentElement(Xml.newDocumentContent(content)));\n    },\n};\n","/**\n * Currency Helper utility for parse string to number with currency value.\n */\nexport class CurrencyDecimals {\n    private readonly _currency: string;\n\n    private readonly _decimals: number;\n\n    constructor(currency: string, decimals: number) {\n        if (!/^[A-Z]{3}$/.test(currency)) {\n            throw new Error('Property currency is not valid');\n        }\n\n        if (decimals < 0) {\n            throw new Error('Property decimals cannot be less than zero');\n        }\n\n        this._currency = currency;\n        this._decimals = Math.floor(decimals);\n    }\n\n    public static decimalsCount(value: string): number {\n        const values = value.split('.');\n        const decimals = values.length > 1 ? values.at(-1) : undefined;\n        return decimals ? decimals.length : 0;\n    }\n\n    public static newFromKnownCurrencies(currency: string, defaultValue?: number): CurrencyDecimals {\n        let decimals = CurrencyDecimals.knownCurrencyDecimals(currency);\n        if (decimals < 0) {\n            if (!defaultValue) {\n                throw new RangeError(`The currency ${currency} is not known`);\n            }\n\n            decimals = defaultValue;\n        }\n\n        return new CurrencyDecimals(currency, decimals);\n    }\n\n    public static knownCurrencyDecimals(currency: string): number {\n        const map: Record<string, number> = {\n            MXN: 2,\n            EUR: 2,\n            USD: 2,\n            XXX: 0,\n        };\n        return map[currency] || -1;\n    }\n\n    public currency(): string {\n        return this._currency;\n    }\n\n    public decimals(): number {\n        return this._decimals;\n    }\n\n    public round(value: number): number {\n        return Number.parseFloat(value.toFixed(this.decimals()));\n    }\n\n    public doesNotExceedDecimals(value: string): boolean {\n        return CurrencyDecimals.decimalsCount(value) <= this.decimals();\n    }\n}\n"],"mappings":"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","names":["src_exports","__export","CAttributes","CNode","CNodes","CNodesSorter","CurrencyDecimals","DOMNotFoundError","DomValidators","Xml","XmlNodeUtils","getDom","getParser","getSerializer","install","__toCommonJS","DOMNotFoundError","type","_dom","_parser","_serializer","getParser","DOMNotFoundError","getSerializer","getDom","install","parser","serializer","dom","DomValidators","nodo","Xml","document","DomValidators","node","getDom","content","parser","getParser","documentParse","error","name","makeElement","errorMessage","element","previousException","CAttributes","_CAttributes","attributes","key","value","name","Xml","found","fixedValue","jsonResponse","offset","CNodesSorter","_CNodesSorter","order","a","b","testValue","key","value","names","entry","isValidName","name","element","index","nodes","aNumber","bNumber","input","callable","list","comparar","node","CNodes","_CNodes","nodes","CNodesSorter","somethingChange","node","names","index","position","value","nodeName","CNode","name","attributes","children","value","Xml","CAttributes","CNodes","node","searchPath","attribute","nodes","nodeName","parent","child","searchName","offset","XmlNodeExporter","node","document","Xml","rootElement","element","key","value","child","childElement","nodo","XmlNodeImporter","element","node","CNode","attribute","children","DomValidators","childNode","prefix","uri","values","XmlNodeUtils","node","XmlNodeExporter","withXmlHeader","element","document","pi","getSerializer","XmlNodeImporter","content","Xml","CurrencyDecimals","_CurrencyDecimals","currency","decimals","value","values","defaultValue"]}